#include <stdlib.h>
#include <string.h>
#include "../include/crypto/aria.h"

// S-box S1. S-box do substitution for confusion.
const uint8_t S1[256] = {
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};

// S-box S1's inverse. S-box do substitution for confusion.
const uint8_t S1_i[256] = {
    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};

// S-box S2. S-box do substitution for confusion.
const uint8_t S2[256] = {
    0xe2, 0x4e, 0x54, 0xfc, 0x94, 0xc2, 0x4a, 0xcc, 0x62, 0x0d, 0x6a, 0x46, 0x3c, 0x4d, 0x8b, 0xd1,
    0x5e, 0xfa, 0x64, 0xcb, 0xb4, 0x97, 0xbe, 0x2b, 0xbc, 0x77, 0x2e, 0x03, 0xd3, 0x19, 0x59, 0xc1,
    0x1d, 0x06, 0x41, 0x6b, 0x55, 0xf0, 0x99, 0x69, 0xea, 0x9c, 0x18, 0xae, 0x63, 0xdf, 0xe7, 0xbb,
    0x00, 0x73, 0x66, 0xfb, 0x96, 0x4c, 0x85, 0xe4, 0x3a, 0x09, 0x45, 0xaa, 0x0f, 0xee, 0x10, 0xeb,
    0x2d, 0x7f, 0xf4, 0x29, 0xac, 0xcf, 0xad, 0x91, 0x8d, 0x78, 0xc8, 0x95, 0xf9, 0x2f, 0xce, 0xcd,
    0x08, 0x7a, 0x88, 0x38, 0x5c, 0x83, 0x2a, 0x28, 0x47, 0xdb, 0xb8, 0xc7, 0x93, 0xa4, 0x12, 0x53,
    0xff, 0x87, 0x0e, 0x31, 0x36, 0x21, 0x58, 0x48, 0x01, 0x8e, 0x37, 0x74, 0x32, 0xca, 0xe9, 0xb1,
    0xb7, 0xab, 0x0c, 0xd7, 0xc4, 0x56, 0x42, 0x26, 0x07, 0x98, 0x60, 0xd9, 0xb6, 0xb9, 0x11, 0x40,
    0xec, 0x20, 0x8c, 0xbd, 0xa0, 0xc9, 0x84, 0x04, 0x49, 0x23, 0xf1, 0x4f, 0x50, 0x1f, 0x13, 0xdc,
    0xd8, 0xc0, 0x9e, 0x57, 0xe3, 0xc3, 0x7b, 0x65, 0x3b, 0x02, 0x8f, 0x3e, 0xe8, 0x25, 0x92, 0xe5,
    0x15, 0xdd, 0xfd, 0x17, 0xa9, 0xbf, 0xd4, 0x9a, 0x7e, 0xc5, 0x39, 0x67, 0xfe, 0x76, 0x9d, 0x43,
    0xa7, 0xe1, 0xd0, 0xf5, 0x68, 0xf2, 0x1b, 0x34, 0x70, 0x05, 0xa3, 0x8a, 0xd5, 0x79, 0x86, 0xa8,
    0x30, 0xc6, 0x51, 0x4b, 0x1e, 0xa6, 0x27, 0xf6, 0x35, 0xd2, 0x6e, 0x24, 0x16, 0x82, 0x5f, 0xda,
    0xe6, 0x75, 0xa2, 0xef, 0x2c, 0xb2, 0x1c, 0x9f, 0x5d, 0x6f, 0x80, 0x0a, 0x72, 0x44, 0x9b, 0x6c,
    0x90, 0x0b, 0x5b, 0x33, 0x7d, 0x5a, 0x52, 0xf3, 0x61, 0xa1, 0xf7, 0xb0, 0xd6, 0x3f, 0x7c, 0x6d,
    0xed, 0x14, 0xe0, 0xa5, 0x3d, 0x22, 0xb3, 0xf8, 0x89, 0xde, 0x71, 0x1a, 0xaf, 0xba, 0xb5, 0x81
};

// S-box S2's inverse. S-box do substitution for confusion.
const uint8_t S2_i[256] = {
    0x30, 0x68, 0x99, 0x1b, 0x87, 0xb9, 0x21, 0x78, 0x50, 0x39, 0xdb, 0xe1, 0x72, 0x09, 0x62, 0x3c,
    0x3e, 0x7e, 0x5e, 0x8e, 0xf1, 0xa0, 0xcc, 0xa3, 0x2a, 0x1d, 0xfb, 0xb6, 0xd6, 0x20, 0xc4, 0x8d,
    0x81, 0x65, 0xf5, 0x89, 0xcb, 0x9d, 0x77, 0xc6, 0x57, 0x43, 0x56, 0x17, 0xd4, 0x40, 0x1a, 0x4d,
    0xc0, 0x63, 0x6c, 0xe3, 0xb7, 0xc8, 0x64, 0x6a, 0x53, 0xaa, 0x38, 0x98, 0x0c, 0xf4, 0x9b, 0xed,
    0x7f, 0x22, 0x76, 0xaf, 0xdd, 0x3a, 0x0b, 0x58, 0x67, 0x88, 0x06, 0xc3, 0x35, 0x0d, 0x01, 0x8b,
    0x8c, 0xc2, 0xe6, 0x5f, 0x02, 0x24, 0x75, 0x93, 0x66, 0x1e, 0xe5, 0xe2, 0x54, 0xd8, 0x10, 0xce,
    0x7a, 0xe8, 0x08, 0x2c, 0x12, 0x97, 0x32, 0xab, 0xb4, 0x27, 0x0a, 0x23, 0xdf, 0xef, 0xca, 0xd9,
    0xb8, 0xfa, 0xdc, 0x31, 0x6b, 0xd1, 0xad, 0x19, 0x49, 0xbd, 0x51, 0x96, 0xee, 0xe4, 0xa8, 0x41,
    0xda, 0xff, 0xcd, 0x55, 0x86, 0x36, 0xbe, 0x61, 0x52, 0xf8, 0xbb, 0x0e, 0x82, 0x48, 0x69, 0x9a,
    0xe0, 0x47, 0x9e, 0x5c, 0x04, 0x4b, 0x34, 0x15, 0x79, 0x26, 0xa7, 0xde, 0x29, 0xae, 0x92, 0xd7,
    0x84, 0xe9, 0xd2, 0xba, 0x5d, 0xf3, 0xc5, 0xb0, 0xbf, 0xa4, 0x3b, 0x71, 0x44, 0x46, 0x2b, 0xfc,
    0xeb, 0x6f, 0xd5, 0xf6, 0x14, 0xfe, 0x7c, 0x70, 0x5a, 0x7d, 0xfd, 0x2f, 0x18, 0x83, 0x16, 0xa5,
    0x91, 0x1f, 0x05, 0x95, 0x74, 0xa9, 0xc1, 0x5b, 0x4a, 0x85, 0x6d, 0x13, 0x07, 0x4f, 0x4e, 0x45,
    0xb2, 0x0f, 0xc9, 0x1c, 0xa6, 0xbc, 0xec, 0x73, 0x90, 0x7b, 0xcf, 0x59, 0x8f, 0xa1, 0xf9, 0x2d,
    0xf2, 0xb1, 0x00, 0x94, 0x37, 0x9f, 0xd0, 0x2e, 0x9c, 0x6e, 0x28, 0x3f, 0x80, 0xf0, 0x3d, 0xd3,
    0x25, 0x8a, 0xb5, 0xe7, 0x42, 0xb3, 0xc7, 0xea, 0xf7, 0x4c, 0x11, 0x33, 0x03, 0xa2, 0xac, 0x60
};

// Constants used in the round key generation
const uint8_t CK[3][16] = {
    {0x51, 0x7c, 0xc1, 0xb7, 0x27, 0x22, 0x0a, 0x94, 0xfe, 0x13, 0xab, 0xe8, 0xfa, 0x9a, 0x6e, 0xe0},
    {0x6d, 0xb1, 0x4a, 0xcc, 0x9e, 0x21, 0xc8, 0x20, 0xff, 0x28, 0xb1, 0xd5, 0xef, 0x5d, 0xe2, 0xb0},
    {0xdb, 0x92, 0x37, 0x1d, 0x21, 0x26, 0xe9, 0x70, 0x03, 0x24, 0x97, 0x75, 0x04, 0xe8, 0xc9, 0x0e}
};


void ARIA_encrypt(uint8_t * output, uint8_t * input, uint8_t * key, unsigned int key_len)
{
    aria_context context;
    unsigned int nr;
    unsigned int i;
    unsigned int j;
    uint8_t state[ARIA_BLOCK_SIZE];
    uint8_t temp[ARIA_BLOCK_SIZE] = { 0x00, };
    uint8_t * rk;

    // 암호화 정보를 저장할 구조체를 초기화하고 암호화 키를 확장한다.
    ARIA_init(&context);
    context.nk = key_len;
    key_expansion(&context, key, ENCRYPT);
    
    // state 변수에 input 값을 복사하고 암호화에 사용할 확장된 키에 대한 포인터를 가져온다.
    memcpy(state, input, ARIA_BLOCK_SIZE);
    rk = (uint8_t *)context.round_key;

    // 확장된 키를 사용해 암호화를 수행한다.
                        // printf("%s:\n", (ENC_DEC == ARIA_ENCRYPT) ? "Encryption" : "Decryption");
    nr = 8 + (key_len / 4);
    for (i = 1; i < nr; ++i)
    {
        round_function(temp, state, rk + ARIA_BLOCK_SIZE * (i - 1), i % 2);
        memcpy(state, temp, ARIA_BLOCK_SIZE);

                        // printf("%s%d round : ", (i < 10) ? " " : "", i); for (j = 0; j < ARIA_BLOCK_SIZE; ++j) printf("%02X ", state[j]); printf("\n");
    }

    ARIA_XOR(state, state, rk + ARIA_BLOCK_SIZE * (nr - 1));
    ARIA_substitution(state, 0);
    ARIA_XOR(output, state, rk + ARIA_BLOCK_SIZE * nr);

                        // printf("%d round : ", nr); for (j = 0; j < ARIA_BLOCK_SIZE; ++j) printf("%02X ", cipher_text[j]); printf("\n\n");
                        
}

void ARIA_decrypt(uint8_t * output, uint8_t * input, uint8_t * key, unsigned int key_len)
{
    aria_context context;
    unsigned int nr;
    unsigned int i;
    unsigned int j;
    uint8_t state[ARIA_BLOCK_SIZE];
    uint8_t temp[ARIA_BLOCK_SIZE] = { 0x00, };
    uint8_t * rk;

    // 암호화 정보를 저장할 구조체를 초기화하고 암호화 키를 확장한다.
    ARIA_init(&context);
    context.nk = key_len;
    key_expansion(&context, key, DECRYPT);
    
    // state 변수에 input 값을 복사하고 암호화에 사용할 확장된 키에 대한 포인터를 가져온다.
    memcpy(state, input, ARIA_BLOCK_SIZE);
    rk = (uint8_t *)context.round_key;

    // 확장된 키를 사용해 암호화를 수행한다.
                        // printf("%s:\n", (ENC_DEC == ARIA_ENCRYPT) ? "Encryption" : "Decryption");
    nr = 8 + (key_len / 4);
    for (i = 1; i < nr; ++i)
    {
        round_function(temp, state, rk + ARIA_BLOCK_SIZE * (i - 1), i % 2);
        memcpy(state, temp, ARIA_BLOCK_SIZE);

                        // printf("%s%d round : ", (i < 10) ? " " : "", i); for (j = 0; j < ARIA_BLOCK_SIZE; ++j) printf("%02X ", state[j]); printf("\n");
    }

    ARIA_XOR(state, state, rk + ARIA_BLOCK_SIZE * (nr - 1));
    ARIA_substitution(state, 0);
    ARIA_XOR(output, state, rk + ARIA_BLOCK_SIZE * nr);

                        // printf("%d round : ", nr); for (j = 0; j < ARIA_BLOCK_SIZE; ++j) printf("%02X ", cipher_text[j]); printf("\n\n");
}

void ARIA_init(aria_context * context)
{
    memset(context, 0, sizeof(aria_context));
}

void key_expansion(aria_context * context, uint8_t * key, PROCESS ENC_DEC)
{
    uint8_t W[4][ARIA_BLOCK_SIZE];
                        unsigned int i, j;

    key_init(W, key, context->nk);
                        // for (i = 0; i < 4; ++i)
                        // {
                        //     printf("W[%d] : ", i);
                        //     for (j = 0; j < ARIA_BLOCK_SIZE; ++j) printf("%02X ", W[i][j]);
                        //     printf("\n");
                        // }
                        // printf("\n");

    make_round_key(context, W, ENC_DEC);

                        // printf("%s keys:\n", (ENC_DEC == ENCRYPT) ? "Encryption" : "Decryption");
                        // for (i = 0; i < 9 + (context->nk / 4) - 1; ++i)
                        // {
                        //     printf("%s%d round key : ", (i < 9) ? " " : "", i + 1);
                        //     for (j = 0; j < ARIA_BLOCK_SIZE; ++j) printf("%02X ", context->round_key[i][j]);
                        //     printf("\n");
                        // }
                        // printf("             : "); for (j = 0; j < ARIA_BLOCK_SIZE; ++j) printf("%02X ", context->round_key[9 + (context->nk / 4) - 1][j]); printf("\n\n");
}

void key_init(uint8_t W[4][ARIA_BLOCK_SIZE], uint8_t * key, unsigned int nk)
{
    uint8_t KR[ARIA_BLOCK_SIZE] = {0, };
    
    const uint8_t * CK_i[4];

    unsigned int i;

    // Setting KL(W[0]) and KR with key and zeroise the key
    memcpy(W[0], key, ARIA_BLOCK_SIZE);
    memcpy(KR, key + ARIA_BLOCK_SIZE, nk - ARIA_BLOCK_SIZE); 
    // for (i = 0; i < ARIA_BLOCK_SIZE; ++i) key[i] = 0x00;

                        // printf("KL :");
                        // for (i = 0; i < ARIA_BLOCK_SIZE; ++i) printf(" %02X", W[0][i]);
                        // printf("\n");

                        // printf("KR :");
                        // for (i = 0; i < ARIA_BLOCK_SIZE; ++i) printf(" %02X", KR[i]);
                        // printf("\n");

    // W 생성
    CK_i[0] = NULL;
    if (nk == 16)       { CK_i[1] = CK[0]; CK_i[2] = CK[1]; CK_i[3] = CK[2]; }
    else if (nk == 24)  { CK_i[1] = CK[1]; CK_i[2] = CK[2]; CK_i[3] = CK[0]; }
    else if (nk == 32)  { CK_i[1] = CK[2]; CK_i[2] = CK[0]; CK_i[3] = CK[1]; }

    
    for (i = 1; i < 4; ++i)
    {
        round_function(W[i], W[i-1], CK_i[i], i % 2);
        ARIA_XOR(W[i], W[i], KR);
        if (i != 3) memcpy(KR, W[i-1], ARIA_BLOCK_SIZE);
    }
}

void round_function(uint8_t * out, uint8_t * in, const uint8_t * CK, unsigned int is_odd)
{
    uint8_t temp[ARIA_BLOCK_SIZE];
                        // unsigned int i;
    
    ARIA_XOR(temp, in, CK);

                        // printf("key_add = ");
                        // for (i = 0; i < ARIA_BLOCK_SIZE; ++i) printf("%02X ", temp[i]);
                        // printf("\n");

    ARIA_substitution(temp, is_odd);
                        // printf("s_box = ");
                        // for (i = 0; i < ARIA_BLOCK_SIZE; ++i) printf("%02X ", temp2[i]);
                        // printf("\n");

    ARIA_diffusion(out, temp);
                        // printf("diff_layer = ");
                        // for (i = 0; i < ARIA_BLOCK_SIZE; ++i) printf("%02X ", out[i]);
                        // printf("\n\n");
}

void ARIA_XOR(uint8_t * dest, uint8_t * src1, const uint8_t * src2)
{
    unsigned int i;

    for (i = 0; i < ARIA_BLOCK_SIZE; ++i)
        dest[i] = src1[i] ^ src2[i];
}

void ARIA_substitution(uint8_t * x, unsigned int is_odd)
{
    const uint8_t * LT[4];
    
    unsigned int i;

    if (is_odd)
        { LT[0] = S1; LT[1] = S2; LT[2] = S1_i; LT[3] = S2_i; }
    else
        { LT[0] = S1_i; LT[1] = S2_i; LT[2] = S1; LT[3] = S2; }
    
    for (i = 0; i < ARIA_BLOCK_SIZE; ++i)
        x[i] = LT[i % 4][x[i]];
}

void ARIA_diffusion(uint8_t * y, const uint8_t * x)
{
    uint8_t T;

    T = x[ 3] ^ x[ 4] ^ x[ 9] ^ x[14];
    y[ 0] = T ^ x[ 6] ^ x[ 8] ^ x[13];
    y[ 5] = T ^ x[ 1] ^ x[10] ^ x[15];
    y[11] = T ^ x[ 2] ^ x[ 7] ^ x[12];
    y[14] = T ^ x[ 0] ^ x[ 5] ^ x[11];

    T = x[ 2] ^ x[ 5] ^ x[ 8] ^ x[15];
    y[ 1] = T ^ x[ 7] ^ x[ 9] ^ x[12];
    y[ 4] = T ^ x[ 0] ^ x[11] ^ x[14];
    y[10] = T ^ x[ 3] ^ x[ 6] ^ x[13];
    y[15] = T ^ x[ 1] ^ x[ 4] ^ x[10];

    T = x[ 1] ^ x[ 6] ^ x[11] ^ x[12];
    y[ 2] = T ^ x[ 4] ^ x[10] ^ x[15];
    y[ 7] = T ^ x[ 3] ^ x[ 8] ^ x[13];
    y[ 9] = T ^ x[ 0] ^ x[ 5] ^ x[14];
    y[12] = T ^ x[ 2] ^ x[ 7] ^ x[ 9];

    T = x[ 0] ^ x[ 7] ^ x[10] ^ x[13];
    y[ 3] = T ^ x[ 5] ^ x[11] ^ x[14];
    y[ 6] = T ^ x[ 2] ^ x[ 9] ^ x[12];
    y[ 8] = T ^ x[ 1] ^ x[ 4] ^ x[15];
    y[13] = T ^ x[ 3] ^ x[ 6] ^ x[ 8];
}

void make_round_key(aria_context * context, uint8_t W[4][ARIA_BLOCK_SIZE], unsigned int ENC_DEC)
{
    unsigned int i, j;
    unsigned int nr;
    uint8_t temp[ARIA_BLOCK_SIZE];
    int index;

    uint8_t * rk = (uint8_t *)(context->round_key);

    if (ENC_DEC == ENCRYPT)
    {
        ROT_XOR(rk + (ARIA_BLOCK_SIZE *  0), W[0], W[1], 19);
        ROT_XOR(rk + (ARIA_BLOCK_SIZE *  1), W[1], W[2], 19);
        ROT_XOR(rk + (ARIA_BLOCK_SIZE *  2), W[2], W[3], 19);
        ROT_XOR(rk + (ARIA_BLOCK_SIZE *  3), W[3], W[0], 19);
        ROT_XOR(rk + (ARIA_BLOCK_SIZE *  4), W[0], W[1], 31);
        ROT_XOR(rk + (ARIA_BLOCK_SIZE *  5), W[1], W[2], 31);
        ROT_XOR(rk + (ARIA_BLOCK_SIZE *  6), W[2], W[3], 31);
        ROT_XOR(rk + (ARIA_BLOCK_SIZE *  7), W[3], W[0], 31);
        ROT_XOR(rk + (ARIA_BLOCK_SIZE *  8), W[0], W[1], 67);
        ROT_XOR(rk + (ARIA_BLOCK_SIZE *  9), W[1], W[2], 67);
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * 10), W[2], W[3], 67);
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * 11), W[3], W[0], 67);
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * 12), W[0], W[1], 97);
        if (context->nk > 16)
        {
            ROT_XOR(rk + (ARIA_BLOCK_SIZE * 13), W[1], W[2], 97);
            ROT_XOR(rk + (ARIA_BLOCK_SIZE * 14), W[2], W[3], 97);
        }
        if (context->nk > 24)
        {
            ROT_XOR(rk + (ARIA_BLOCK_SIZE * 15), W[3], W[0], 97);
            ROT_XOR(rk + (ARIA_BLOCK_SIZE * 16), W[0], W[1], 109);
        }
    }
    else
    {
        index = 0;
                                                                        // Nk  32   24   16
        if (context->nk > 24)
        {
            ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[0], W[1], 109);   //  0
            ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[3], W[0], 97);    //  1
        }
        if (context->nk > 16)
        {
            ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[2], W[3], 97);    //  2    0
            ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[1], W[2], 97);    //  3    1
        }
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[0], W[1], 97);        //  4    2    0
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[3], W[0], 67);        //  5    3    1
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[2], W[3], 67);        //  6    4    2
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[1], W[2], 67);        //  7    5    3
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[0], W[1], 67);        //  8    6    4
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[3], W[0], 31);        //  9    7    5
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[2], W[3], 31);        // 10    8    6
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[1], W[2], 31);        // 11    9    7
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[0], W[1], 31);        // 12   10    8
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[3], W[0], 19);        // 13   11    9
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[2], W[3], 19);        // 14   12   10
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[1], W[2], 19);        // 15   13   11
        ROT_XOR(rk + (ARIA_BLOCK_SIZE * (index++)), W[0], W[1], 19);        // 16   14   12

        nr = 8 + (context->nk / 4);
        for (i = 1; i < nr; ++i)
        {
            memcpy(temp, rk + (ARIA_BLOCK_SIZE * i), ARIA_BLOCK_SIZE);
            ARIA_diffusion(rk + (ARIA_BLOCK_SIZE * i), temp);
        }
    }
    
    for (i = 0; i < 4; ++i)
            for (j = 0; j < ARIA_BLOCK_SIZE; ++j)
                W[i][j] = 0x00;
}

void ROT_XOR(uint8_t * out, uint8_t * XOR_target, uint8_t * ROT_target, unsigned int rot_count)
{
    unsigned int i;

    unsigned int q = rot_count / 8;
    unsigned int r = rot_count % 8;

    for (i = 0; i < ARIA_BLOCK_SIZE; ++i)
    {
        out[(q + i) % ARIA_BLOCK_SIZE] ^= ROT_target[i] >> r;
        if (r != 0)
            out[(q + i + 1) % ARIA_BLOCK_SIZE] ^= ROT_target[i] << (8 - r);
    }

    for (i = 0; i < ARIA_BLOCK_SIZE; ++i)
        out[i] ^= XOR_target[i];
}
